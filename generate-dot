#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""Generates a dot file using the task data in the subdirectory "tasks."
"""
import argparse
import errno
import json
import io
import os
import pathlib
import sys

def main(argv) -> int:
    """Main application to be invoked.
    Takes zero or one arguments.
    If zero arguments or there is one argument with the value "dash",
    write output to stdout.
    Otherwise write output to the file path given.

    Returns:
      An integral system errno.
    """
    args = get_parser().parse_args(argv)
    if args.output in [None, '-']:
        output_fd = sys.stdout
    else:
        output_fd = open(args.output, 'r')

    status = emit_dot(args.first_node.stem, output_fd)
    output_fd.close()
    return status

def get_parser() -> argparse.ArgumentParser:
    parser = argparse.ArgumentParser(
        description='Generates a dot file with task data specified in the '
                    'subdirectory "tasks."')
    parser.add_argument('--first-node', '-f',
        required=True,
        type=pathlib.Path,
        help='First task that begins the task graph search. '
             'This can be a path or the name of the task.')
    parser.add_argument('--output', '-o',
        help='Output dot file. If unspecified, writes to stdout.')

    return parser

class NodeData:
    """Parse a generic dict into required and optional dependency components.
    """
    def __init__(self, name, seed_dict: dict = {}):
        self.name = name
        self.short = seed_dict['short']
        if 'requires' in seed_dict:
            self.requires = seed_dict['requires']
        else:
            self.requires = []
        if 'optional' in seed_dict:
            self.optional = seed_dict['optional']
        else:
            self.optional = []

    def __str__(self):
        """String representation of node data.
        Meant to be written out to graphviz node label.
        """
        return "{name}\n{desc}".format(
            name=self.name,
            desc=self.short)

def emit_dot_graph_contents(node_name: str, output_file: io.IOBase):
    """Create the contents of a graphviz graph with proper dot syntax.
    Current implementation is meant to run breadth-first-search and be invoked
    recursively.
    """
    node_path = pathlib.Path(__file__).resolve().parent
    node_path /= 'tasks'
    node_path /= node_name + '.json'

    with open(node_path.as_posix(), 'r') as node_fd:
        node_data = NodeData(node_name, json.load(node_fd))

    output_file.write('"{}" [label = "{}"]\n'.format(
        node_name, str(node_data)))

    for req in node_data.requires:
        output_file.write('"{}" -> "{}"\n'.format(node_path.stem, req))
    for opt in node_data.optional:
        output_file.write('"{}" -> "{}"\n'.format(node_path.stem, opt))

    for req in node_data.requires:
        emit_dot_graph_contents(req, output_file)
    for opt in node_data.optional:
        emit_dot_graph_contents(opt, output_file)

    return 0

def emit_dot(node_name: str, output_file: io.IOBase):
    """Create full graphviz dot file generating the graph of dependencies.
    Originally intended to write out the boiler plate to leave graph content
    generation to a subroutine.
    """
    output_file.write('digraph G {\n')

    exit_status = emit_dot_graph_contents(node_name, output_file)
    if 0 != exit_status:
        return exit_status

    output_file.write('}\n')
    return 0

if __name__ == '__main__':
    sys.exit(main(sys.argv[1:]))
